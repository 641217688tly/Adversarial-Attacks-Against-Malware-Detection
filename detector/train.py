from dataset import *
from tensorboardX import SummaryWriter
from resnet18 import resnet18

import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data


def train_model(model_path, epoch, train_benign_path, train_malignant_path, test_benign_path, test_malignant_path):
    writer = SummaryWriter(comment="ResNet")

    dataset = get_dataset(train_benign_path, train_malignant_path)
    train_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=64)

    dataset = get_dataset(test_benign_path, test_malignant_path)
    test_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=256)

    # 使用二元交叉熵损失函数
    criterion = nn.BCEWithLogitsLoss().cuda()

    model = resnet18().cuda()  # Updated to use the new resnet_18 model

    # Update TensorBoard graph input to reflect the new input dimensions
    temp = torch.rand(32, 1, 16, 8).cuda()  # Updated for 12x12 grayscale images
    writer.add_graph(model, (temp,))

    optimizer = optim.Adam(model.parameters(), lr=1e-3)

    best_accuracy = 0.0
    step = 0

    for i in range(epoch):
        print("epoch:", i)
        model.train()
        for j, data in enumerate(train_loader):
            x, y = data
            x = x.cuda()
            y = y.cuda().view(-1, 1).float()  # Update the shape of y to match output

            optimizer.zero_grad()
            prediction = model(x)

            # Update loss calculation to match new output shape
            loss = criterion(prediction, y)

            loss.backward()
            optimizer.step()

            writer.add_scalar("Loss", loss.item(), step)
            step += 1

        print('--------Validation--------')
        model.eval()
        with torch.no_grad():
            correct = 0
            total = 0
            for j, data in enumerate(test_loader):
                x, y = data
                x = x.cuda()
                y = y.cuda().view(-1, 1).float()  # Update the shape of y to match output

                output = model(x)
                predicted = torch.sigmoid(output) > 0.5  # Use a threshold of 0.5
                correct += (predicted == y).sum().item()
                total += y.size(0)

            accuracy = correct / total
            writer.add_scalar("Accuracy", accuracy, i)
            if accuracy > best_accuracy:
                torch.save(model.state_dict(), "".join(model_path.split('.')[:-1]) + "_best.pth")
                best_accuracy = accuracy

    torch.save(model.state_dict(), model_path)
    writer.close()