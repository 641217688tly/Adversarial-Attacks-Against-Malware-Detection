import numpy as np

# 定义了一个从.bytes文件中获取十六进制序列的函数。
# 这个函数将.bytes文件中的每行的第二个到最后一个字符串(十六进制数)提取出来，存储在一个列表中，并返回这个列表。
def get_hex_sequence(filename):
    """
    Get hexadecimal sequence from .bytes file.
    :param filename: The name of .bytes file
    :return: The hexadecimal sequence
    """
    hex_seq = []  # 用于保存十六进制序列的列表
    with open(filename, 'r') as f:
        a = f.readline()
        while a:
            line = a.split()[1:]  # 忽略每行开头的地址信息，只提取十六进制数
            hex_seq += line  # 将提取出的十六进制数添加到列表中
            a = f.readline()
    return hex_seq

# 这个函数将从.bytes文件中提取的十六进制序列转换成一个n*宽度的矩阵，
# 其中宽度根据文件大小确定。"??"是一个占位符，表示不确定的值，在这个函数中被忽略。
def hex2mat(filename):
    """
    Convert a hexadecimal sequence to a n * width matrix, where width is determined by the file size.
    "??" is ignored.
    :param filename: Given .bytes file
    :return: n * width array
    """
    hex_seq = get_hex_sequence(filename)  # 获取十六进制序列
    vec_seq = []
    for i in range(len(hex_seq)):
        if hex_seq[i] != "??":
            vec_seq.append(int(hex_seq[i], 16))  # 将十六进制数转换为十进制数，并添加到列表中
        # else:
        #     vec_seq.append(0)  # 如果遇到"??", 就添加一个0（这一行被注释掉了，意味着"??"会被忽略）

    if vec_seq == []:
        return None

    file_size = len(vec_seq) / 1024.0  # 计算文件大小（KB）
    # 根据不同的文件大小，设定不同的宽度
    if file_size < 10:
        width = 32
    elif file_size < 30:
        width = 64
    elif file_size < 60:
        width = 128
    elif file_size < 100:
        width = 256
    elif file_size < 200:
        width = 384
    elif file_size < 500:
        width = 512
    elif file_size < 1000:
        width = 768
    else:
        width = 1024

    # 如果vec_seq的长度不是width的倍数，用0填充至是width的倍数
    residual = len(vec_seq) % width
    if residual:
        vec_seq += [0] * (width - residual)

    vec_seq = np.asarray(vec_seq)  # 将列表转换为NumPy数组

    return np.reshape(vec_seq, (-1, width))  # 将一维数组转换为二维数组，形状为(n, width)
