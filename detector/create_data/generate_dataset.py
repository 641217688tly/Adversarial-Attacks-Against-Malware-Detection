import os
import shutil
import pandas as pd
import torch
import random

from PIL import Image
from torch.utils.data import Dataset
from detector.create_data.bytes2img import *


# 定义一个表示恶意软件数据的类，继承自PyTorch的Dataset类。
class MalwareData(torch.utils.data.Dataset):
    def __init__(self, images, labels):
        self.images = images  # 保存图像路径的列表。
        self.labels = labels  # 保存标签的列表。

    def __getitem__(self, item):
        path = self.images[item]  # 根据索引获取图像路径。
        label = self.labels[item]  # 根据索引获取标签。

        image = Image.open(path)  # 打开图像文件。
        image = image.resize((224, 224))  # 将图像调整为224x224大小。
        mat = np.asarray(image, dtype=np.float32)  # 将图像转换为NumPy数组，并指定数据类型为float32。
        mat = np.reshape(mat, (1, 224, 224))  # 将数组重塑为(1, 224, 224)的形状。
        mat = np.repeat(mat, 3, axis=0)  # 在第0个维度上重复数组3次，以满足CNN模型的输入要求。
        image_tensor = torch.from_numpy(mat)  # 将NumPy数组转换为PyTorch张量。

        return image_tensor, label  # 返回图像张量和标签。

    def __len__(self):
        return len(self.labels)  # 返回数据集的大小。


# 将所有的.bytes文件分为9个类别，每个类别代表一个家族。
def split_dataset(src_path, dest_path, label_path):
    """
    Split all .bytes files into 9 categories, each category representing a family.
    :param src_path: The path of all .bytes files.
    :param dest_path: The path of 9 categories.
    :param label_path: The path of labels.csv.
    """
    df = pd.read_csv(label_path)  # 读取labels.csv文件，并保存为pandas的DataFrame对象。

    if not os.path.exists(dest_path):  # 如果目标路径不存在，创建目标路径的目录。
        os.mkdir(dest_path)
    for i in range(1, 10):
        filename_list = df.Id[df['Class'] == i].tolist()  # 获取每个类别的文件名列表。
        filename_list = list(set(filename_list))  # 删除重复的文件名。
        if not os.path.exists(dest_path + str(i)):  # 如果对应类别的目录不存在，创建目录。
            os.mkdir(dest_path + str(i))
        for file_name in filename_list:
            # 移动文件到对应类别的目录。
            shutil.move(src_path + file_name + '.bytes', dest_path + str(i) + '/' + file_name + '.bytes')

    os.rmdir(src_path)  # 删除源路径的目录。


# 将所有.bytes文件分为训练样本和测试样本。
def generate_train_test(bytes_path):
    """
    Split all .bytes files into training samples and test samples.
    :param bytes_path: The path of all .bytes files.
    """
    train_path = '/'.join(bytes_path.split('/')[:-1]) + "/train/"  # 设置训练样本的保存路径。
    test_path = '/'.join(bytes_path.split('/')[:-1]) + "/test/"  # 设置测试样本的保存路径。

    dirs = os.listdir(bytes_path)  # 列出.bytes文件所在目录的所有子目录。
    for dir in dirs:
        files = os.listdir(bytes_path + dir)  # 列出每个子目录中的所有文件。

        num = len(files)
        train_num = int(num * 0.8)  # 计算80%的文件用作训练样本。

        if not os.path.exists(train_path):  # 如果训练样本保存路径不存在，创建目录。
            os.mkdir(train_path)
        if not os.path.exists(test_path):  # 如果测试样本保存路径不存在，创建目录。
            os.mkdir(test_path)
        if not os.path.exists(train_path + dir):  # 如果训练样本的子目录不存在，创建目录。
            os.mkdir(train_path + dir)
        if not os.path.exists(test_path + dir):  # 如果测试样本的子目录不存在，创建目录。
            os.mkdir(test_path + dir)

        for bytes in files[0:train_num]:
            shutil.move(bytes_path + dir + '/' + bytes, train_path + dir + '/' + bytes)  # 移动文件到训练样本目录。
        for bytes in files[train_num:]:
            shutil.move(bytes_path + dir + '/' + bytes, test_path + dir + '/' + bytes)  # 移动文件到测试样本目录。

        os.rmdir(bytes_path + dir)  # 删除原来的子目录。


# 将.bytes文件转换为.bmp文件，并保存。
def generate_dataset(src_path, dest_path):
    """
    Convert .bytes files to .bytes.mat files and save them as .bmp.
    :param src_path: The path of all .bytes files.
    :param dest_path: The path of all .bmp files.
    """
    dirs = os.listdir(src_path)  # 列出源路径的所有子目录。
    for dir in dirs:
        if not os.path.exists(dest_path + dir):  # 如果目标路径的子目录不存在，创建目录。
            os.mkdir(dest_path + dir)
        for file in os.listdir(src_path + dir):  # 遍历源路径子目录中的所有文件。
            mat = hex2mat(src_path + dir + '/' + file)  # 调用hex2mat函数将.bytes文件转换为矩阵。
            if mat is not None and mat.size:
                img = Image.fromarray(mat)  # 将矩阵转换为图像。
                img = img.convert("L")  # 将图像转换为灰度图。
                img.save(dest_path + dir + '/' + file.split('.')[0] + '.bmp')  # 保存图像为.bmp文件。
            else:
                print(f"Warning: Skipping {file} as the matrix is None or empty.")


# 获取数据集。
def get_dataset(src_path):
    """
    Get dataset from training path or test path.
    :param src_path: The path of .bytes files.
    :return: Training dataset or test dataset.
    """
    x = []  # 存储.bmp文件的路径。
    y = []  # 存储对应的标签。
    dirs = os.listdir(src_path)  # 列出源路径的所有子目录。
    for dir in dirs:
        for file in os.listdir(src_path + dir):  # 遍历子目录中的所有文件。
            x.append(src_path + dir + '/' + file)  # 添加文件路径到x列表。
            y.append(int(dir) - 1)  # 添加标签到y列表。

    temp = list(zip(x, y))  # 将x和y列表组成一个列表，其中每个元素都是一个(x, y)元组。
    random.shuffle(temp)  # 随机打乱数据。
    x[:], y[:] = zip(*temp)  # 解压缩打乱后的数据，并赋值回x和y列表。

    return MalwareData(x, y)  # 创建一个MalwareData对象，并返回。


if __name__ == "__main__":
    bytes_src_path = "D:/1University/stage 3/4Software Methodology/Research/Malware domain/Malware Classification/Dataset/Kaggle Dataset/train/bytes/"
    dest_path = "D:/1University/stage 3/4Software Methodology/Research/Malware domain/Malware Classification/Dataset/Kaggle Dataset/train/classified_bytes/"
    labels_csv_path = "D:/1University/stage 3/4Software Methodology/Research/Malware domain/Malware Classification/Dataset/Kaggle Dataset/trainLabels.csv"

    train_bmp_data_path = "D:/1University/stage 3/4Software Methodology/Research/Malware domain/Malware Classification/Dataset/Processed Dataset/bytes/train/"
    test_bmp_data_path = "D:/1University/stage 3/4Software Methodology/Research/Malware domain/Malware Classification/Dataset/Processed Dataset/bytes/test/"

    # split_dataset(bytes_src_path, dest_path, labels_csv_path)
    # generate_train_test(dest_path)
    # generate_dataset(dest_path + "train/", train_bmp_data_path)
    # generate_dataset(dest_path + "test/", test_bmp_data_path)
    dataset = get_dataset(test_bmp_data_path)  # 获取测试数据集。
    print(dataset)  # 打印数据集的信息。
    print(dataset.labels)  # 打印数据集的标签。


# Warning: Skipping 58kxhXouHzFd4g3rmInB.bytes as the matrix is None or empty.
# Warning: Skipping 6tfw0xSL2FNHOCJBdlaA.bytes as the matrix is None or empty.
# Warning: Skipping a9oIzfw03ED4lTBCt52Y.bytes as the matrix is None or empty.
# Warning: Skipping cf4nzsoCmudt1kwleOTI.bytes as the matrix is None or empty.
# Warning: Skipping d0iHC6ANYGon7myPFzBe.bytes as the matrix is None or empty.
# Warning: Skipping da3XhOZzQEbKVtLgMYWv.bytes as the matrix is None or empty.
# Warning: Skipping fRLS3aKkijp4GH0Ds6Pv.bytes as the matrix is None or empty.
# Warning: Skipping IidxQvXrlBkWPZAfcqKT.bytes as the matrix is None or empty.
