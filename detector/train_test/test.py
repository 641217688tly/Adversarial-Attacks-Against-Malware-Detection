from detector.create_data.generate_dataset import get_dataset
from sklearn.metrics import accuracy_score, precision_score, f1_score, recall_score, confusion_matrix
import torch
import torch.utils.data
import numpy as np
import matplotlib.pyplot as plt

# 定义一个函数，用于绘制混淆矩阵
def draw_confusion_matrix(mat):
    np.set_printoptions(precision=3)  # 设置NumPy打印选项的精度
    mat = mat.astype('float') / mat.sum(axis=1)[:, np.newaxis]  # 归一化混淆矩阵
    plt.figure(figsize=(12, 8), dpi=120)  # 设置图像大小和分辨率

    index = np.arange(9)
    x, y = np.meshgrid(index, index)  # 生成网格坐标
    for x_val, y_val in zip(x.flatten(), y.flatten()):
        value = mat[y_val][x_val]  # 获取混淆矩阵中的值
        plt.text(x_val, y_val, "%0.3f" % value, color='red', fontsize=7, va='center', ha='center')  # 在图上标注值

    tick_marks = np.array(range(9)) + 0.5  # 设置刻度

    # 设置图像的刻度和格线
    plt.gca().set_xticks(tick_marks, minor=True)
    plt.gca().set_yticks(tick_marks, minor=True)
    plt.gca().xaxis.set_ticks_position('none')
    plt.gca().yaxis.set_ticks_position('none')
    plt.grid(True, which='minor', linestyle='-')
    plt.gcf().subplots_adjust(bottom=0.15)

    plt.imshow(mat, interpolation='nearest', cmap=plt.cm.binary)  # 显示混淆矩阵图像
    plt.title("Confusion Matrix")  # 设置标题
    plt.colorbar()  # 显示颜色条
    labels = ['Ramnit', 'Lollipop', 'Kelihos_ver3', 'Vundo', 'Simda', 'Tracur', 'Kelihos_ver1', 'Obfuscator.ACY', 'Gatak']
    x_location = np.array(range(9))
    plt.xticks(x_location, labels, rotation=90)  # 设置x轴刻度和标签
    plt.yticks(x_location, labels)  # 设置y轴刻度和标签
    plt.ylabel('True Label')  # 设置y轴标签
    plt.xlabel('Predicted Label')  # 设置x轴标签
    plt.savefig('confusion_matrix.png', format='png')  # 保存图像到文件
    plt.show()  # 显示图像

# 定义一个函数，用于测试模型
def test_model(model_path):
    """
    测试指定模型的性能。
    :param model_path: 加载模型的路径。
    """
    test_path = input("Please input the path of test data: ")  # 获取测试数据的路径
    if test_path[-1] != '/':
        test_path += '/'

    dataset = get_dataset(test_path)  # 加载测试数据集

    model = torch.load(model_path).cuda()  # 加载模型并将其移动到GPU

    test_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=28)  # 创建数据加载器

    model.eval()  # 将模型设置为评估模式
    with torch.no_grad():  # 关闭梯度计算
        y_prediction = []  # 用于存储预测的标签
        y = dataset.labels  # 真实标签
        for i, data in enumerate(test_loader):  # 遍历测试数据
            x, _ = data
            x = x.cuda()  # 将数据移动到GPU
            output = model(x)  # 获取模型输出
            y_prediction += list(torch.argmax(output, 1).cpu())  # 将输出转换为预测的标签

        y_prediction = list(map(int, y_prediction))  # 将预测的标签转换为整数类型

        # 计算并打印各种评估指标
        confusion_mat = confusion_matrix(y_true=y, y_pred=y_prediction)
        accuracy = accuracy_score(y_true=y, y_pred=y_prediction)
        precision = precision_score(y_true=y, y_pred=y_prediction, average='weighted')
        recall = recall_score(y_true=y, y_pred=y_prediction, average='weighted')
        f1 = f1_score(y_true=y, y_pred=y_prediction, average='weighted')

        print(confusion_mat)
        draw_confusion_matrix(confusion_mat)  # 绘制混淆矩阵
        print('accuracy:', accuracy)
        print('precision:', precision)
        print('recall:', recall)
        print('f1_score', f1)
