import argparse # 导入标准库argparse，用于解析命令行参数和选项
import pickle # 导入标准库pickle，用于对象的序列化和反序列化
import sys # 导入标准库sys，提供了一些变量和函数，用来与Python解释器进行交互
from typing import Union # 导入typing模块中的Union，用于类型注解，表示一个变量可以是多种类型中的一种
from pathlib import Path # 导入pathlib模块中的Path类，提供了一种面向对象的方式来处理文件系统路径
import numpy as np # 导入第三方库NumPy，用于进行高效的数组和矩阵运算
from gan import MalGAN, MalwareDataset, BlackBoxDetector, setup_logger # 导入本地模块malgan，其中包含了MalGAN、MalwareDataset、BlackBoxDetector等类和函数
import torch # 导入第三方库torch，提供了一个多维数组的张量，可以在其上执行高效的数学运算
from torch import nn # 导入torch库中的nn模块，提供了构建神经网络所需的类和函数

# 这个函数用于解析命令行参数
def parse_args() -> argparse.Namespace:
    """
    解析命令行参数

    :return: 解析后的参数结构
    """
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Z是潜在向量的维度
    parser.add_argument("Z", help="Dimension of the latent vector", type=int, default=10)
    # batch_size是每批训练数据的大小
    parser.add_argument("batch_size", help="Batch size", type=int, default=32)
    # num_epoch是训练周期的总数
    parser.add_argument("num_epoch", help="Number of training epochs", type=int, default=100)

    # 用于加载恶意软件和良性软件特征向量的数据文件
    msg = "Data file contacting the %s feature vectors"
    for x in ["malware", "benign"]:
        parser.add_argument(x[:3] + "_file", help=msg % x, type=str, default="data/%s.npy" % x)

    # -q 参数用于开启静默模式，减少输出
    parser.add_argument("-q", help="Quiet mode", action='store_true', default=False)

    # 生成器的隐藏层大小
    help_msg = " ".join(["Dimension of the hidden layer(s) in the GENERATOR."
                         "Multiple layers should be space separated"])
    parser.add_argument("--gen-hidden-sizes", help=help_msg, type=int,
                        default=[256, 256], nargs="+")

    # 判别器的隐藏层大小
    help_msg = " ".join(["Dimension of the hidden layer(s) in the DISCRIMINATOR."
                         "Multiple layers should be space separated"])
    parser.add_argument("--discrim-hidden-sizes", help=help_msg, type=int,
                        default=[256, 256], nargs="+")

    # 生成器和判别器隐藏层的激活函数
    help_msg = " ".join(["Activation function for the generator and discriminator hidden",
                         "layer(s). Valid choices (case insensitive) are: \"ReLU\", \"ELU\",",
                         "\"LeakyReLU\", \"tanh\" and \"sigmoid\"."])
    parser.add_argument("--activation", help=help_msg, type=str, default="LeakyReLU")

    # 黑盒检测器的学习算法
    help_msg = ["Learner algorithm used in the black box detector. Valid choices (case ",
                "insensitive) include:"]
    names = BlackBoxDetector.Type.names()
    for i, type_name in enumerate(names):
        if i > 0 and len(names) > 2:  # 需要至少三个选项，逗号才有意义
            help_msg.append(",")
        if len(names) > 1 and i == len(names) - 1:  # 且只有在至少有两个选项时才有意义
            help_msg.append(" and")
        help_msg.extend([" \"", type_name, "\""])
    help_msg.append(".")
    parser.add_argument("--detector", help="".join(help_msg), type=str,
                        default=BlackBoxDetector.Type.ResNet.name)

    # 是否在控制台打印结果，用于slurm结果分析
    help_msg = "Print the results to the console. Intended for slurm results analysis"
    parser.add_argument("--print-results", help=help_msg, action="store_true", default=False)

    args = parser.parse_args()
    # 将激活函数和检测器类型转换为正确的格式
    args.activation = _configure_activation_function(args.activation)
    args.detector = BlackBoxDetector.Type.get_from_name(args.detector)

    # 检查恶意软件和良性文件是否存在
    args.mal_file = Path(args.mal_file)
    args.ben_file = Path(args.ben_file)
    for (name, path) in (("malware", args.mal_file), ("benign", args.ben_file)):
        if path.exists(): continue
        print(f"Unknown %s file \"%s\"" % (name, str(path)))
        sys.exit(1)
    return args

def _configure_activation_function(act_func_name: str) -> nn.Module:
    r"""
    Parse the activation function from a string and return the corresponding activation function
    PyTorch module. If the activation function cannot not be found, a \p ValueError is thrown.

    **Note**: Activation function check is case insensitive.

    :param act_func_name: Name of the activation function to
    :return: Activation function module associated with the passed name.
    """
    # 这里将激活函数名称转换为小写，以使得检查过程不受大小写影响
    act_func_name = act_func_name.lower()  # Make case insensitive
    # 定义支持的激活函数及其对应的PyTorch模块
    act_funcs = [
        ("relu", nn.ReLU),
        ("elu", nn.ELU),
        ("leakyrelu", nn.LeakyReLU),
        ("tanh", nn.Tanh),
        ("sigmoid", nn.Sigmoid)
    ]
    for func_name, module in act_funcs:
        # 检查是否找到了对应的激活函数
        if act_func_name == func_name.lower():
            # 返回对应的激活函数模块
            return module()
    # 如果没有找到对应的激活函数，抛出错误
    raise ValueError("Unknown activation function: \"%s\"" % act_func_name)


def load_dataset(file_path: Union[str, Path], y: int) -> MalwareDataset:
    r"""
    Extracts the input data from disk and packages them into format expected by \p MalGAN.  Supports
    loading files from numpy, torch, and pickle. Other formats (based on the file extension) will
    result in a \p ValueError.

    :param file_path: Path to a NumPy data file containing tensors for the benign and malware data.
    :param y: Y value for dataset
    :return: \p MalwareDataset objects for the malware and benign files respectively.
    """
    # 获取文件扩展名
    file_ext = Path(file_path).suffix
    # 根据文件扩展名决定如何加载数据
    if file_ext in {".npy", ".npz"}:
        # 加载NumPy数据文件
        data = np.load(file_path)
    elif file_ext in {".pt", ".pth"}:
        # 加载PyTorch张量文件
        data = torch.load(str(file_path))
    elif file_ext == ".pk":
        # 加载pickle序列化文件
        with open(str(file_path), "rb") as f_in:
            data = pickle.load(f_in)
    else:
        # 未知文件扩展名，抛出错误
        raise ValueError("Unknown file extension.  Cannot determine how to import")
    # 返回MalwareDataset对象
    return MalwareDataset(x=data, y=y)


def main():
    args = parse_args()  # 解析命令行参数
    setup_logger(args.q)  # 设置日志记录

    # 设置全局变量，这里是恶意软件批处理大小
    MalGAN.MALWARE_BATCH_SIZE = args.batch_size
    print(MalGAN.MALWARE_BATCH_SIZE)  # 打印当前批处理大小
    # 初始化MalGAN对象
    malgan = MalGAN(
        load_dataset(args.mal_file, MalGAN.Label.Malware.value),
        load_dataset(args.ben_file, MalGAN.Label.Benign.value),
        Z=args.Z,
        h_gen=args.gen_hidden_sizes,
        h_discrim=args.discrim_hidden_sizes,
        g_hidden=args.activation,
        detector_type=args.detector
    )
    malgan.fit(args.num_epoch, quiet_mode=args.q)  # 训练MalGAN
    results = malgan.measure_and_export_results()  # 获取并导出结果
    # 如果命令行参数中指定了打印结果，那么在控制台打印结果
    if args.print_results:
        print(results)

if __name__ == "__main__":
    main()
