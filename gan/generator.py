from typing import List, Tuple # 引入 typing 模块中的 List 和 Tuple，用于类型注解，提高代码可读性
import numpy as np
import torch
from torch import Tensor
import torch.nn as nn  # nn 模块包含了构建神经网络所需的所有组件

TensorTuple = Tuple[Tensor, Tensor] # 定义一个元组类型 TensorTuple，包含两个 Tensor 元素

class Generator(nn.Module):
    r""" MalGAN generator block """

    # 初始化函数，构建生成器网络
    def __init__(self, M: int, Z: int, hidden_size: List[int], g: nn.Module):
        r"""Generator Constructor
        :param M: 特征向量 m 的维度
        :param Z:  噪声向量 z 的维度
        :param hidden_size: 隐藏层的宽度
        :param g: 激活函数
        """
        super().__init__()
        self._Z = Z
        self._layers = nn.Sequential()
        dim = [M + self._Z] + hidden_size

        for i, (d_in, d_out) in enumerate(zip(dim[:-1], dim[1:])):
            # 添加全连接层
            self._layers.add_module("FF%02d" % i, nn.Linear(d_in, d_out))
            # 添加批量归一化层
            self._layers.add_module("BN%02d" % i, nn.BatchNorm1d(d_out))
            # 添加 Dropout 层
            self._layers.add_module("DO%02d" % i, nn.Dropout(0.2))
            # 添加激活函数
            self._layers.add_module("AC%02d" % i, g)

        # 输出层，不添加BN层
        final_layer = nn.Sequential(nn.Linear(dim[-1], M), nn.Sigmoid())
        self._layers.add_module("FF_Out", final_layer)

    # 前向传播函数，m 为输入特征向量，z 为噪声向量
    def forward(self, m: torch.Tensor, z: torch.Tensor = None) -> TensorTuple:
        r"""
        Forward pass through the generator.  Automatically generates the noise vector z that
        is coupled with m.

        :param m: 输入向量 m
        :param z: 噪声向量 z;如果没有指定随机向量，则在此函数调用中通过调用  torch.rand 生成随机向量
        :return: 返回一个元组 (:math:`m'`, :math:`G_{\theta_{g}}`),即输出张量,包含特征预测和可用于反向传播的平滑预测
        """
        if z is None:
            num_ele = m.shape[0]
            z = torch.rand((num_ele, self._Z))  # 生成随机噪声向量

        # 将输入向量 m 和噪声向量 z 拼接
        o = torch.cat((m, z), dim=1)
        o = self._layers.forward(o)  # 通过神经网络
        g_theta = torch.max(m, o)  # 将维度为128的o中新出现的特征API添加给m
        m_prime = (g_theta > 0.5).float()  # 将 g_theta 的值四舍五入为 0 或 1,得到m'
        return m_prime, g_theta

