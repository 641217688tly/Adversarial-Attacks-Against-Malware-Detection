from enum import Enum
from typing import Union  # 引入了类型注解Union，用于定义多个类型的联合类型
import numpy as np
import sklearn  # 引入了Scikit-learn机器学习库，用于实现多种机器学习算法
from PIL.Image import Image
from sklearn.tree import DecisionTreeClassifier  # 引入了决策树分类器
from sklearn.ensemble import RandomForestClassifier  # 引入了随机森林分类器
from sklearn.linear_model import LogisticRegression  # 引入了逻辑回归分类器
from sklearn.neural_network import MLPClassifier  # 引入了多层感知机分类器
from sklearn.svm import SVC  # 引入了支持向量机分类器
import torch
import torch.nn as nn
from torch import Tensor
from .resnet18 import resnet18  # 引入了ResNet18模型

TorchOrNumpy = Union[np.ndarray, Tensor]  # 表示可以是NumPy数组或PyTorch张量


class BlackBoxDetector:  # 类BlackBoxDetector是一个黑盒检测器，模拟了一个防病毒/防恶意软件程序
    r"""
    Black box detector that intends to mimic an antivirus/anti-Malware program that detects whether
    a specific program is either malware or benign.
    """

    # Enum类Type定义了黑盒检测器可以使用的学习算法类型
    class Type(Enum):
        r""" Learner algorithm to be used by the black-box detector """
        DecisionTree = DecisionTreeClassifier()
        LogisticRegression = LogisticRegression(solver='lbfgs', max_iter=int(1e6))
        MultiLayerPerceptron = MLPClassifier()
        RandomForest = RandomForestClassifier(n_estimators=100)
        SVM = SVC(gamma="auto")
        ResNet = resnet18()

        @classmethod
        def names(cls):
            r""" Builds the list of all enum names """
            return [c.name for c in cls]

        @classmethod
        def get_from_name(cls, name):
            r"""
            Gets the enum item from the specified name
            :param name: Name of the enum object
            :return: Enum item associated with the specified name
            """
            for c in BlackBoxDetector.Type:
                if c.name == name:
                    return c
            raise ValueError("Unknown enum \"%s\" for class \"%s\"", name, cls.name)

    def __init__(self, learner_type: 'BlackBoxDetector.Type'):
        self.type = learner_type  # 指定学习算法类型
        if self.type == BlackBoxDetector.Type.ResNet:
            print(f"Loading BlackBox Detector: ResNet18")
            model = resnet18()
            state_dict = torch.load(
                "D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/gan/resnet18_epoch18_best.pth",
                map_location=torch.device('cuda'))
            model.load_state_dict(state_dict)
            model.cuda()  # 将模型移动到 GPU
            model.eval()
            self._model = model
        else:
            # 使用sklearn.clone创建学习模型的副本，确保模型参数的独立性
            self._model = sklearn.clone(self.type.value)

        # 标记模型是否在训练中
        self.training = True if self.type != BlackBoxDetector.Type.ResNet else False

    # fit方法用于训练模型
    def fit(self, X: TorchOrNumpy, y: TorchOrNumpy):
        r"""
        Fits the learner.Supports NumPy and PyTorch arrays as input. Returns a torch tensor as output.
        :param X: Examples upon which to train
        :param y: Labels for the examples
        """
        # 如果输入是PyTorch张量，将其转换为NumPy数组
        if self.type == BlackBoxDetector.Type.ResNet:
            return  # 如果是预训练的ResNet，不执行训练操作
        else:
            if isinstance(X, Tensor):
                X = X.cpu().numpy()
            if isinstance(y, Tensor):
                y = y.cpu().numpy()
            # 使用fit方法训练模型
            self._model.fit(X, y)
            # 设置训练标志为False，表示训练完成
            self.training = False

    # predict方法用于对输入的样本进行预测
    def predict(self, X: TorchOrNumpy) -> Tensor:
        r"""
        Predict the labels for X
        :param X: Set of examples for which label probabilities should be predicted
        :return: Predicted value for X
        """
        if self.type == BlackBoxDetector.Type.ResNet:
            # 使用ResNet模型进行预测
            with torch.no_grad():  # 关闭梯度计算
                predictions, labels = self._model.predict(X)
            labels = labels.squeeze()
            # print(f"预测值的shape: {labels.shape}")
            # print(f"黑盒检测器预测值: {labels}")
            return labels
        else:
            # 如果模型还没有训练，则抛出异常
            if self.training:
                raise ValueError("Detector does not appear to be trained but trying to predict")
            # 如果CUDA可用，将输入转移到CPU上，因为Scikit-learn不支持GPU
            if torch.cuda.is_available():
                X = X.cpu()
            # 如果输入是PyTorch张量，将其转换为NumPy数组
            if isinstance(X, Tensor):
                X = X.numpy()
            # 使用模型的predict方法进行预测，并将结果转换为PyTorch张量
            y = torch.from_numpy(self._model.predict(X)).float()
            # print(f"预测值的shape: {y.shape}")
            # print(f"黑盒检测器预测值: {y}") #黑盒检测器预测值: tensor([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],device='cpu')
            # 如果CUDA可用，将结果转移到GPU上
            return y.cuda() if torch.cuda.is_available() else y
