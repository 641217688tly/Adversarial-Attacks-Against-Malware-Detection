from enum import Enum
from typing import Union  # 引入了类型注解Union，用于定义多个类型的联合类型
import numpy as np
import sklearn  # 引入了Scikit-learn机器学习库，用于实现多种机器学习算法
from PIL.Image import Image
from sklearn.tree import DecisionTreeClassifier  # 引入了决策树分类器
from sklearn.ensemble import RandomForestClassifier  # 引入了随机森林分类器
from sklearn.linear_model import LogisticRegression  # 引入了逻辑回归分类器
from sklearn.neural_network import MLPClassifier  # 引入了多层感知机分类器
from sklearn.svm import SVC  # 引入了支持向量机分类器
from torch import nn
import torch
from torch import Tensor


# BasicBlock类定义了ResNet网络中的基本残差块
class BasicBlock(nn.Module):
    expansion = 1

    def __init__(self, in_channels, out_channels, stride=1, downsample=None):
        super(BasicBlock, self).__init__()
        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=3, stride=stride, padding=1, bias=False)
        self.bn1 = nn.BatchNorm2d(out_channels)
        self.relu = nn.ReLU(inplace=True)
        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, stride=1, padding=1, bias=False)
        self.bn2 = nn.BatchNorm2d(out_channels)
        self.downsample = downsample
        self.stride = stride

    def forward(self, x):
        residual = x
        out = self.conv1(x)
        out = self.bn1(out)
        out = self.relu(out)
        out = self.conv2(out)
        out = self.bn2(out)
        if self.downsample is not None:
            residual = self.downsample(x)
        out += residual
        out = self.relu(out)
        return out



# ResNet类定义了完整的ResNet网络
class ResNet(nn.Module):
    def __init__(self, block, layers, num_classes=2):
        super(ResNet, self).__init__()
        self.in_channels = 64
        # Adjusted the initial convolutional layer for 16x8 input
        self.conv1 = nn.Conv2d(1, 64, kernel_size=3, stride=1, padding=1, bias=False)
        self.bn1 = nn.BatchNorm2d(64)
        self.relu = nn.ReLU(inplace=True)
        self.layer1 = self._make_layer(block, 64, layers[0])
        self.layer2 = self._make_layer(block, 128, layers[1], stride=1)
        self.layer3 = self._make_layer(block, 256, layers[2], stride=1)
        self.layer4 = self._make_layer(block, 512, layers[3], stride=1)
        self.avgpool = nn.AdaptiveAvgPool2d((1, 1)) # Adaptive pooling to handle the small input size
        self.fc = nn.Linear(512 * block.expansion, num_classes)
        for m in self.modules():
            if isinstance(m, nn.Conv2d):
                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')
            elif isinstance(m, nn.BatchNorm2d):
                nn.init.constant_(m.weight, 1)
                nn.init.constant_(m.bias, 0)

    def _make_layer(self, block, out_channels, blocks, stride=1):
        downsample = None
        if stride != 1 or self.in_channels != out_channels * block.expansion:
            downsample = nn.Sequential(
                nn.Conv2d(self.in_channels, out_channels * block.expansion, kernel_size=1, stride=stride, bias=False),
                nn.BatchNorm2d(out_channels * block.expansion),
            )
        layers = []
        layers.append(block(self.in_channels, out_channels, stride, downsample))
        self.in_channels = out_channels * block.expansion
        for i in range(1, blocks):
            layers.append(block(self.in_channels, out_channels))
        return nn.Sequential(*layers)

    def forward(self, x):
        x = self.conv1(x)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.layer1(x)
        x = self.layer2(x)
        x = self.layer3(x)
        x = self.layer4(x)
        x = self.avgpool(x)
        x = x.view(x.size(0), -1)
        x = self.fc(x)
        x = torch.sigmoid(x) # Applying sigmoid to get probabilities
        return x

def resnet18():
    # Instantiate the ResNet model for 12x12 grayscale images
    model = ResNet(BasicBlock, [2, 2, 2, 2], num_classes=1)
    return model


TorchOrNumpy = Union[np.ndarray, Tensor]  # 表示可以是NumPy数组或PyTorch张量

class BlackBoxDetector:  # 类BlackBoxDetector是一个黑盒检测器，模拟了一个防病毒/防恶意软件程序
    r"""
    Black box detector that intends to mimic an antivirus/anti-Malware program that detects whether
    a specific program is either malware or benign.
    """

    # Enum类Type定义了黑盒检测器可以使用的学习算法类型
    class Type(Enum):
        r""" Learner algorithm to be used by the black-box detector """
        DecisionTree = DecisionTreeClassifier()
        LogisticRegression = LogisticRegression(solver='lbfgs', max_iter=int(1e6))
        MultiLayerPerceptron = MLPClassifier()
        RandomForest = RandomForestClassifier(n_estimators=100)
        SVM = SVC(gamma="auto")
        ResNet = resnet18()
        @classmethod
        def names(cls):
            r""" Builds the list of all enum names """
            return [c.name for c in cls]

        @classmethod
        def get_from_name(cls, name):
            r"""
            Gets the enum item from the specified name

            :param name: Name of the enum object
            :return: Enum item associated with the specified name
            """
            for c in BlackBoxDetector.Type:
                if c.name == name:
                    return c
            raise ValueError("Unknown enum \"%s\" for class \"%s\"", name, cls.name)

    def __init__(self, learner_type: 'BlackBoxDetector.Type'):
        self.type = learner_type  # 指定学习算法类型
        if self.type == BlackBoxDetector.Type.ResNet:
            print(f"Loading BlackBox Detector: ResNet18")
            # model = torch.load("D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/gan/resnet18_epoch18_best.pth")
            # model.eval()  # 将模型设置为评估模式
            # self._model = model
            model = resnet18()
            state_dict = torch.load("D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/gan/resnet18_epoch18_best.pth", map_location=torch.device('cuda'))
            model.load_state_dict(state_dict)
            model.cuda()  # 将模型移动到 GPU
        else:
            # 使用sklearn.clone创建学习模型的副本，确保模型参数的独立性
            self._model = sklearn.clone(self.type.value)
        # 标记模型是否在训练中
        self.training = True if self.type != BlackBoxDetector.Type.ResNet else False

    # fit方法用于训练模型
    def fit(self, X: TorchOrNumpy, y: TorchOrNumpy):
        r"""
        Fits the learner.  Supports NumPy and PyTorch arrays as input.  Returns a torch tensor
        as output.

        :param X: Examples upon which to train
        :param y: Labels for the examples
        """
        # 如果输入是PyTorch张量，将其转换为NumPy数组
        if self.type == BlackBoxDetector.Type.ResNet:
             return # 如果是预训练的ResNet，不执行训练操作
        else:
            if isinstance(X, Tensor):
                X = X.cpu().numpy()
            if isinstance(y, Tensor):
                y = y.cpu().numpy()
            # 使用fit方法训练模型
            self._model.fit(X, y)
            # 设置训练标志为False，表示训练完成
            self.training = False

    # predict方法用于对输入的样本进行预测
    def predict(self, X: TorchOrNumpy) -> Tensor:
        r"""
        Predict the labels for \p X

        :param X: Set of examples for which label probabilities should be predicted
        :return: Predicted value for \p X
        """
        if self.type == BlackBoxDetector.Type.ResNet:
            # 将输入的每一个128维向量转换为16x8的灰度图像
            images = [self.vector_to_image(x) for x in X]
            # 将列表转换为Tensor
            images_tensor = torch.stack(images)
            # 使用ResNet模型进行预测
            with torch.no_grad():  # 关闭梯度计算
                predictions = self._model(images_tensor)
            return predictions

        else:
            # 如果模型还没有训练，则抛出异常
            if self.training:
                raise ValueError("Detector does not appear to be trained but trying to predict")
            # 如果CUDA可用，将输入转移到CPU上，因为Scikit-learn不支持GPU
            if torch.cuda.is_available():
                X = X.cpu()
            # 如果输入是PyTorch张量，将其转换为NumPy数组
            if isinstance(X, Tensor):
                X = X.numpy()
            # 使用模型的predict方法进行预测，并将结果转换为PyTorch张量
            y = torch.from_numpy(self._model.predict(X)).float()
            # 如果CUDA可用，将结果转移到GPU上
            return y.cuda() if torch.cuda.is_available() else y

    @staticmethod
    def vector_to_image(vector: np.ndarray) -> Tensor:
        # 将128维向量重塑为16x8的矩阵
        matrix = np.reshape(vector, (16, 8))
        # 将矩阵转换为灰度图像，并转换为Tensor
        image_tensor = torch.from_numpy(matrix).unsqueeze(0).unsqueeze(0)  # 增加通道和批次维度
        # 标准化图像数据到[0, 1]范围
        image_tensor = image_tensor.float() / 255.0
        return image_tensor
