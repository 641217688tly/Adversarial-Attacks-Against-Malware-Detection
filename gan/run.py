import torch.utils.data
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
import matplotlib.pyplot as plt

from tensorboardX import SummaryWriter
from resnet18 import resnet18
import torch.nn as nn
import torch.optim as optim
import torch.utils.data
import os
import random
import numpy as np
import torch
from PIL import Image
from torch.utils.data import Dataset

class MalwareData(Dataset):
    def __init__(self, images, labels):
        self.images = images
        self.labels = labels

    def __getitem__(self, index):
        # Load image as a gray scale image
        image_path = self.images[index]
        image = Image.open(image_path).convert('L')  # Convert to grayscale
        image = np.array(image, dtype=np.float32)  # Convert image to numpy array
        # Resize image to 16x8 if not already
        if image.shape != (16, 8):
            image = Image.fromarray(image).resize((8, 16))  # Resize to 16x8
            image = np.array(image, dtype=np.float32)
        image_tensor = torch.from_numpy(image).unsqueeze(0)  # Add channel dimension
        # Normalize the image to [0, 1] range
        image_tensor = image_tensor / 255.0
        label = self.labels[index]
        return image_tensor, label
    def __len__(self):
        return len(self.labels)

def get_dataset(benign_path, malignant_path):
    x = []
    y = []
    # Load benign images
    benign_files = [os.path.join(benign_path, f) for f in os.listdir(benign_path)]
    x.extend(benign_files)
    y.extend([0] * len(benign_files))  # Label for benign is 0
    # Load malignant images
    malignant_files = [os.path.join(malignant_path, f) for f in os.listdir(malignant_path)]
    x.extend(malignant_files)
    y.extend([1] * len(malignant_files))  # Label for malignant is 1
    # Shuffle the dataset
    dataset = list(zip(x, y))
    random.shuffle(dataset)
    x[:], y[:] = zip(*dataset)

    return MalwareData(x, y)

def train_model(model_path, epoch, train_benign_path, train_malignant_path, test_benign_path, test_malignant_path):
    writer = SummaryWriter(comment="ResNet")

    dataset = get_dataset(train_benign_path, train_malignant_path)
    train_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=64)

    dataset = get_dataset(test_benign_path, test_malignant_path)
    test_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=256)

    # Updated loss function for binary classification
    criterion = nn.BCEWithLogitsLoss().cuda()

    model = resnet18().cuda()  # Updated to use the new resnet_18 model

    # Update TensorBoard graph input to reflect the new input dimensions
    temp = torch.rand(32, 1, 16, 8).cuda()  # Updated for 12x12 grayscale images
    writer.add_graph(model, (temp,))

    optimizer = optim.Adam(model.parameters(), lr=1e-3)

    best_accuracy = 0.0
    step = 0

    for i in range(epoch):
        print("epoch:", i)
        model.train()
        for j, data in enumerate(train_loader):
            x, y = data
            x = x.cuda()
            y = y.cuda().view(-1, 1).float()  # Update the shape of y to match output

            optimizer.zero_grad()
            prediction = model(x)

            # Update loss calculation to match new output shape
            loss = criterion(prediction, y)

            loss.backward()
            optimizer.step()

            writer.add_scalar("Loss", loss.item(), step)
            step += 1

        print('--------Validation--------')
        model.eval()
        with torch.no_grad():
            correct = 0
            total = 0
            for j, data in enumerate(test_loader):
                x, y = data
                x = x.cuda()
                y = y.cuda().view(-1, 1).float()  # Update the shape of y to match output

                output = model(x)
                predicted = torch.sigmoid(output) > 0.5  # Use a threshold of 0.5
                correct += (predicted == y).sum().item()
                total += y.size(0)

            accuracy = correct / total
            writer.add_scalar("Accuracy", accuracy, i)
            if accuracy > best_accuracy:
                torch.save(model.state_dict(), "".join(model_path.split('.')[:-1]) + "_best.pth")
                best_accuracy = accuracy

    torch.save(model.state_dict(), model_path)
    writer.close()


def draw_confusion_matrix(confusion_mat, labels):
    """
    This function draws a confusion matrix for binary classification.
    """
    plt.imshow(confusion_mat, interpolation='nearest', cmap=plt.cm.Blues)
    plt.title('Confusion Matrix')
    plt.colorbar()
    tick_marks = np.arange(len(labels))
    plt.xticks(tick_marks, labels, rotation=45)
    plt.yticks(tick_marks, labels)

    # Print the confusion matrix values on the chart
    for i in range(len(labels)):
        for j in range(len(labels)):
            plt.text(j, i, format(confusion_mat[i, j], 'd'),
                     horizontalalignment="center",
                     color="white" if confusion_mat[i, j] > confusion_mat.max() / 2. else "black")

    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()
    plt.show()


def test_model(model_path, test_benign_path, test_malignant_path):
    """
    This function tests the model and prints out the performance metrics.
    """
    dataset = get_dataset(test_benign_path, test_malignant_path)
    test_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=28)

    # Load model
    model = resnet18()
    model.load_state_dict(torch.load(model_path))
    model.cuda()
    model.eval()

    y_true = []
    y_pred = []

    # No gradient needed for evaluation
    with torch.no_grad():
        for inputs, labels in test_loader:
            inputs = inputs.cuda()
            outputs = model(inputs)
            predicted_probs = torch.sigmoid(outputs)
            predicted_labels = (predicted_probs > 0.5).float()
            y_pred.extend(predicted_labels.view(-1).cpu().numpy())
            y_true.extend(labels.cpu().numpy())

    # Calculate metrics
    accuracy = accuracy_score(y_true, y_pred)
    precision = precision_score(y_true, y_pred)
    recall = recall_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)

    # Generate confusion matrix
    conf_mat = confusion_matrix(y_true, y_pred)
    draw_confusion_matrix(conf_mat, labels=['Benign', 'Malware'])

    # Print performance metrics
    print('Confusion Matrix:\n', conf_mat)
    print('Accuracy: {:.4f}'.format(accuracy))
    print('Precision: {:.4f}'.format(precision))
    print('Recall: {:.4f}'.format(recall))
    print('F1 Score: {:.4f}'.format(f1))


train_benign_path = 'D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/data/trial_ben.bmp/train'
train_malignant_path = 'D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/data/trial_mal.bmp/train'
test_benign_path = 'D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/data/trial_ben.bmp/test'
test_malignant_path = 'D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/data/trial_mal.bmp/test'

# 黑盒检测器(128维):
model_path = "D:/1University/stage 3/4Software Methodology/Research/Adversarial Example Generator/gan/resnet18_epoch18_best.pth"

# 训练模型:
#train_model(model_path, 18, train_benign_path, train_malignant_path, test_benign_path,test_malignant_path)
# 测试模型
#test_model(model_path, test_benign_path, test_malignant_path)
