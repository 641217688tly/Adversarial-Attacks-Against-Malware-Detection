from typing import List, Tuple # 引入 typing 模块中的 List 和 Tuple，用于类型注解，提高代码可读性
import torch
from torch import Tensor
import torch.nn as nn  # nn 模块包含了构建神经网络所需的所有组件


TensorTuple = Tuple[Tensor, Tensor] # 定义一个元组类型 TensorTuple，包含两个 Tensor 元素

# 定义 Generator 类，继承自 nn.Module，nn.Module 是构建所有神经网络的基类
class Generator(nn.Module):
    r""" MalGAN generator block """

    # 初始化函数，构建生成器网络
    def __init__(self, M: int, Z: int, hidden_size: List[int], g: nn.Module):
        r"""Generator Constructor

        :param M: Dimension of the feature vector \p m，特征向量 m 的维度
        :param Z: Dimension of the noise vector \p z，噪声向量 z 的维度
        :param hidden_size: Width of the hidden layer(s)，隐藏层的宽度
        :param g: Activation function，激活函数
        """
        super().__init__()

        self._Z = Z  # 储存噪声向量的维度

        # 构建前馈神经网络
        self._layers, dim = nn.Sequential(), [M + self._Z] + hidden_size
        for i, (d_in, d_out) in enumerate(zip(dim[:-1], dim[1:])):
            self._layers.add_module("FF%02d" % i, nn.Sequential(nn.Linear(d_in, d_out), g))

        # 输出层使用 Sigmoid 函数，确保输出在 [0, 1] 之间
        layer = nn.Sequential(nn.Linear(dim[-1], M), nn.Sigmoid())
        self._layers.add_module("FF%02d" % len(dim), layer)

    # 前向传播函数，m 为输入特征向量，z 为噪声向量
    def forward(self, m: torch.Tensor, z: torch.Tensor = None) -> TensorTuple:
        r"""
        Forward pass through the generator.  Automatically generates the noise vector \p z that
        is coupled with \p m.

        :param m: Input vector :math:`m`，输入向量 m
        :param z: Noise vector :math:`z`。If no random vector is specified, the random vector is
                  generated within this function call via a call to \p torch.rand
                  噪声向量 z。如果没有指定随机向量，则在此函数调用中通过调用 \p torch.rand 生成随机向量
        :return: Tuple of (:math:`m'`, :math:`G_{\theta_{g}}`)，i.e., the output tensor with the
                 feature predictions as well as the smoothed prediction that can be used for
                 back-propagation.
                 返回一个元组 (:math:`m'`, :math:`G_{\theta_{g}}`)，即输出张量，包含特征预测和可用于反向传播的平滑预测。
        """
        if z is None:
            num_ele = m.shape[0]
            z = torch.rand((num_ele, self._Z))  # 生成随机噪声向量

        # 将输入向量 m 和噪声向量 z 拼接
        o = torch.cat((m, z), dim=1)
        o = self._layers.forward(o)  # 通过神经网络
        g_theta = torch.max(m, o)  # 确保二进制位只设置为正

        m_prime = (g_theta > 0.5).float()  # 将 g_theta 的值四舍五入为 0 或 1
        return m_prime, g_theta

